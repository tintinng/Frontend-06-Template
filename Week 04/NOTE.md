学习笔记

### 字典树
#### 概念
字典树又称前缀树或单词查找树，通过将一些事先存在的字符串保存在trie树中，实现字符串检索、前缀匹配和词频统计等功能。是一种专门用来处理字符串匹配的树形结构。
#### 实现
trie树的本质就是利用字符串之间的公共前缀，将重复的前缀保存在一起。如果只处理小写字母，那么trie树的每个节点最多可包含26个子节点和一个存储当前字符串个数的属性。
```javascript
{
    a: {
        ...
    }
    b: {
        d: 2
        $: 2 // 字符串数量
    }
    $: 1    // 字符串数量
}
```
构造trie树的过程就是不断插入字符串的过程，构建Trie树需要扫描所有的字符串，时间复杂度为O(n)，n是所有的额字符串长度。构建好trie树之后，查询和插入的时间复杂度都只用O(k)，k为单个字符串长度。但是当需要统计词频的时候，就需要遍历整个Trie树，时间复杂度为O(n),n为树的节点数量。

#### 应用——搜索关键词提示
在搜索引擎或者表单输入中，输入前缀单词，查询展示以当前输入为前缀的单词。
### KMP
#### 概念
在字符串的匹配过程中，当模式串和主串不匹配时，最简单粗暴的方法就是模式串从头开始匹配，KMP算法就是根据模式串自身的模式特点，在匹配时遇到不匹配的情况不用每次都从头开始匹配，而是尽可能多地从模式串中间再次开始。
#### 实现
KMP最主要的过程就是确定pattern[i]不匹配时，下一个应当匹配的字符，因此对应每一字符串中的每一个字符pattern[i]，都有一个数指示对应不匹配时的下一个跳转，用table数组来表示。KMP算法最主要的过程就是求这一个数组：
```javascript
let table = new Array(pattern.length).fill(0);

    {
        let i = 1, j = 0;
        // 遍历每个字符，j用来设置对应的table[i]，table[0]即为0
        while (i < pattern.length) {
            // 相等则一直往后并设置table[j]
            if (pattern[i] === pattern[j]) {
                ++j, ++i;
                table[i] = j;
            } else { // 否则往前跳
                if (j > 0) {
                    j = table[j];
                } else { // 跳到头就是0，不需要设置
                    ++i;
                }
            }
        }
    }
```
### Wildcard
Wildcard匹配中，*匹配0~n个字符，?匹配单个字符。

使用 * 划分为三段：
- 第一个 * 前面为第一段
- 最后一个 * 后面为第三段
- 第二段则用 * 划分为多个子模式

